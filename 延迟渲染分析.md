# 延迟渲染
延迟渲染的核心思想是将几何处理和光照计算分离，先将几何信息和材质信息渲染到GBuffer中，然后在光照阶段通过GBuffer中的信息进行光照计算。阶段包括：
1. 深度预通道（Depth Pre-Pass）
    * 渲染所有不透明物体的几何信息，输出多个GBuffer纹理（法线、漫反射、高光等）
2. 光照计算（Lighting Pass）
    * 利用GBuffer中的信息，对每个光源进行光照计算，累积光照结果。
3. 半透明渲染
    * 与光照结果混合，渲染半透明物体（前向渲染）
3. 后处理（Post-Processing）
    * 对光照结果进行后处理，如抗锯齿、色调映射等。
# UE延迟渲染阶段对应
UE的延迟渲染在FDeferredShadingSceneRenderer::Render函数中实现，将代码与渲染阶段对应：
1. 深度预通道（Depth Pre-Pass）

    在UE中，深度预通道通过RenderPrePass函数实现。它根据bNeedsPrePass条件判断是否执行。如果启用，会提前渲染深度，并可能生成HZB（Hierarchical Z-Buffer）用于后续的遮挡查询。
2. GBuffer填充（Base Pass）
    
    Base Pass通过RenderBasePass函数实现。它将材质属性（法线、基色、粗糙度、金属度等）渲染到GBuffer中。同时考虑了以下内容：
    * Nanite集成：虚拟化几何体系统
    * 实例剔除：InstanceCullingManager优化性能
    * 材质系统：Substrate材质框架
3. 光照计算（Lighting Pass）

    Lighting Pass包括主要光照计算RenderLights，全局光照（Lumen）RenderDiffuseIndirectAndAmbientOcclusion，反射和天空光RenderDeferredReflectionsAndSkyLighting。这里需要重点关注的内容包括：
    * 多光源处理：FSortedLightSetSceneInfo管理光源排序
    * Lumen全局光照：实时光线追踪GI
    * 屏幕空间反射：SSR技术
    * 阴影集成：虚拟阴影贴图(Virtual Shadow Maps)

4. 半透明阶段

    半透明物体渲染（前向渲染）通过RenderTranslucency完成，该阶段重点考虑了以下内容：
    * 大气渲染：RenderSkyAtmosphere
    * 体积雾：ComputeVolumetricFog
    * 光线遮蔽：RenderLightShaftOcclusion
    * 后期雾效：RenderFog
4. 后处理（Post-Processing）

    后处理在AddPostProcessingPasses函数中实现，该阶段重点考虑了以下内容：
    * TAA时序抗锯齿
    * 色调映射：HDR显示转换
    * 屏幕空间效果：SSAO、SSGI等
    * 自定义后处理：通过ViewFamily.ViewExtensions扩展
# 代码结构分析
通过关键函数调用理清流程：
1. 视图初始化和资源准备

        FInitViewTaskDatas InitViewTaskDatas = OnRenderBegin(GraphBuilder, SceneUpdateInputs);

        // 提交最终管线状态决策
        static_cast<FDeferredShadingSceneRenderer*>(Renderer)->CommitFinalPipelineState();

        // 系统纹理初始化
        GSystemTextures.InitializeTextures(GraphBuilder.RHICmdList, FeatureLevel);

2. 场景环境设置：
    
        // 大气和天空光照设置
        PrepareSunLightProxy(*Scene->GetSkyAtmosphereSceneInfo(), LightIndex, *Scene->AtmosphereLights[LightIndex]);

        // 虚拟阴影贴图初始化
        VirtualShadowMapArray.Initialize(GraphBuilder, Scene->GetVirtualShadowMapCache(), bEnableVirtualShadowMaps, ViewFamily.EngineShowFlags);

         // Lumen场景初始化
        BeginUpdateLumenSceneTasks(GraphBuilder, *InitViewTaskDatas.LumenFrameTemporaries);
        BeginGatherLumenLights(...);

        // Nanite可见性计算
        NaniteVisibility.BeginVisibilityFrame();
        NaniteBasePassVisibility.Query = NaniteVisibility.BeginVisibilityQuery(...);
        
3. 可见性计算和场景处理：
    
        // 距离场场景准备
        PrepareDistanceFieldScene(GraphBuilder, ExternalAccessQueue, *SceneUpdateInputs);

        // 着色能量守恒初始化
        ShadingEnergyConservation::Init(GraphBuilder, View);

        // 光线追踪实例收集
        InitViewTaskDatas.RayTracingGatherInstances = RayTracing::CreateGatherInstancesTaskData(...);
        RayTracing::BeginGatherInstances(...);

        // 虚拟纹理和Nanite流式处理
        UE::SVT::GetStreamingManager().BeginAsyncUpdate(GraphBuilder);
        Nanite::GGlobalResources.Update(GraphBuilder);
        Nanite::GStreamingManager.BeginAsyncUpdate(GraphBuilder);
        bUpdateNaniteStreaming = true;

        // Nanite可视化设置
        // ...
        UE::SVT::GetStreamingManager().EndAsyncUpdate(GraphBuilder);

4. 深度预通道和早期渲染（GBuffer生成）

        // 深度缓冲区清除
        AddClearDepthStencilPass(GraphBuilder, SceneTextures.Depth.Target, DepthLoadAction, StencilLoadAction);

        // 深度预通道渲染
        RenderPrePass(GraphBuilder, InViews, SceneTextures.Depth.Target, ...);

        // 使用velocity pass进行可移动对象的早期速度渲染
        RenderVelocities(GraphBuilder, InViews, SceneTextures, ...);

        // Nanite几何体渲染
        RenderNanite(GraphBuilder, InViews, SceneTextures, ...);

        // 场景纹理设置
        SceneTextures.SetupMode = ESceneTextureSetupMode::SceneDepth;
        SceneTextures.UniformBuffer = CreateSceneTextureUniformBuffer(GraphBuilder, &SceneTextures, FeatureLevel, SceneTextures.SetupMode);

        AddResolveSceneDepthPass(GraphBuilder, InViews, SceneTextures.Depth);
6. 光照计算

        // 光照数据收集和排序
        GatherAndSortLightsTask.Wait();

        // 前向光照数据准备
        ComputeLightGridOutput = PrepareForwardLightData(GraphBuilder, true, *SortedLightSet);

        // 间接光照和AO
        RenderDiffuseIndirectAndAmbientOcclusion(...);

        // 光源渲染
        RenderLights(GraphBuilder, SceneTextures, LightingChannelsTexture, SortedLightSet);

        // 次表面散射
        AddSubsurfacePass(GraphBuilder, SceneTextures, Views);
    
7. 大气、雾效和体积效果

        // 大气渲染
        RenderSkyAtmosphere(GraphBuilder, SceneTextures);
        
        // 雾效渲染
        RenderFog(GraphBuilder, SceneTextures, LightShaftOcclusionTexture, ...);
        
        // 体积云渲染
        RenderVolumetricCloud(GraphBuilder, SceneTextures, ...);
        
8. 半透明物体渲染

        // 半透明物体渲染
        RenderTranslucency(*this, GraphBuilder, SceneTextures, ...);
9. 后处理

        AddPostProcessingPasses(...);
# 通过渲染模块进行扩展
在Render函数中提供了三个通过FRendererModule调用的扩展点，这三个扩展点分别位于渲染管线的不同阶段，允许用户插入自定义的渲染操作，下面根据在代码中这三个扩展点的调用位置，分析它们所处的渲染阶段和可用的数据。
1. RenderPostOpaqueExtensions

    在渲染不透明物体之后，但在半透明物体渲染之前。具体位置在渲染了不透明物体的光照、大气、雾效等之后，以及渲染半透明物体之前。可用资源：
    * FPostOpaqueRenderParameters

    适合绘制一些需要读取深度和场景颜色的自定义效果。
2. RenderOverlayExtensions

    在渲染半透明物体之后，后处理之前。具体位置在渲染了半透明物体、 distortions（扭曲效果）等之后，后处理通道之前。可用资源：
    * FPostOpaqueRenderParameters

    适合绘制在半透明物体之上的自定义效果，比如UI、调试绘制等。
3. RenderPostResolvedSceneColorExtension

    在场景颜色（SceneColor）被解析（Resolve）之后，后处理之前。注意，这个调用是在ResolveSceneColor之后，但在后处理通道之前。可用资源：
    * FRDGBuilder& GraphBuilder, 
    * const FSceneTextures& SceneTextures

    适合需要读取最终场景颜色（包括不透明和半透明）的后处理效果，但不想通过完整的后处理管线的情况。